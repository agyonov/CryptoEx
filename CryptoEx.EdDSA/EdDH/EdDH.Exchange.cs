
using System;
using System.Security.Cryptography;

namespace CryptoEx.Ed.EdDH;

/// <summary>
/// Key exchanges over the Edwards-curve Digital Signature Algorithm (EdDSA)
/// </summary>
public partial class EdDH
{
    /// <summary>
    /// Get shared secret
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <returns>The shared secred</returns>
    public byte[] GetSharedSecret(EdDH publicKey)
    {
        // Result
        byte[] sharedSecret;

        if (_PrivateKey25519 != null && publicKey._PublicKey25519 != null) {
            sharedSecret = new byte[KeySize25519 / 8];
            _PrivateKey25519.GenerateSecret(publicKey._PublicKey25519, sharedSecret);
        } else if (_PrivateKey448 != null && publicKey._PublicKey448 != null) {
            sharedSecret = new byte[KeySize448 / 8];
            _PrivateKey448.GenerateSecret(publicKey._PublicKey448, sharedSecret);
        } else {
            throw new NotSupportedException($"Not supported key pairs for EdDH");
        }

        // return
        return sharedSecret;
    }

    /// <summary>
    /// Get shared secret
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="sharedSecret">A buffer to fill with shared secred</param>
    public void GetSharedSecret(EdDH publicKey, Span<byte> sharedSecret)
    {
        if (_PrivateKey25519 != null && publicKey._PublicKey25519 != null) {
            _PrivateKey25519.GenerateSecret(publicKey._PublicKey25519, sharedSecret);
        } else if (_PrivateKey448 != null && publicKey._PublicKey448 != null) {
            _PrivateKey448.GenerateSecret(publicKey._PublicKey448, sharedSecret);
        } else {
            throw new NotSupportedException($"Not supported key pairs for EdDH");
        }
    }

    /// <summary>
    /// Generate bytes, based on the shared secret.
    /// The bytes are generated by hashing the shared secret with the given hash algorithm.
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="generatedResult">The buffer where to put the resulting shared bytes value</param>
    /// <param name="hashAlgorithm">The hash algorith to use</param>
    /// <returns>The number of bytes written to the generatedResult buffer</returns>
    public int GenerateBytesPure(EdDH publicKey,
                                    Span<byte> generatedResult,
                                    HashAlgorithmName hashAlgorithm)
    {
        // call the other one
        return GenerateBytesPure(publicKey, generatedResult, hashAlgorithm, ReadOnlySpan<byte>.Empty, ReadOnlySpan<byte>.Empty);
    }

    /// <summary>
    /// Generate bytes, based on the shared secret.
    /// The bytes are generated by hashing the shared secret with the given hash algorithm.
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="generatedResult">The buffer where to put the resulting shared bytes value</param>
    /// <param name="hashAlgorithm">The hash algorith to use</param>
    /// <param name="secretPrepend">Bytes to put on front of a shared secret, before hashing. May be empty span!</param>
    /// <param name="secretAppend">Bytes to append to the end of a shared secret, before hashing. May be empty span!</param>
    /// <returns>The number of bytes written to the generatedResult buffer</returns>
    public int GenerateBytesPure(EdDH publicKey,
                                    Span<byte> generatedResult,
                                    HashAlgorithmName hashAlgorithm,
                                    ReadOnlySpan<byte> secretPrepend,
                                    ReadOnlySpan<byte> secretAppend)
    {
        // prepare some buffer
        Span<byte> sharedSecret = stackalloc byte[KeySize / 8 + secretPrepend.Length + secretAppend.Length];
        secretPrepend.CopyTo(sharedSecret);
        GetSharedSecret(publicKey, sharedSecret[secretPrepend.Length..]);
        secretAppend.CopyTo(sharedSecret[(secretPrepend.Length + KeySize / 8)..]);

        // Switch
        switch (hashAlgorithm.Name) {
            case "MD5":
                // Check
                if (generatedResult.Length < MD5.HashSizeInBytes) {
                    throw new ArgumentException($"Invalid length of generatedResult for MD5: {generatedResult.Length}");
                } else {
                    // Calc
                    return MD5.HashData(sharedSecret, generatedResult);
                }
            case "SHA1":
                // Check
                if (generatedResult.Length < SHA1.HashSizeInBytes) {
                    throw new ArgumentException($"Invalid length of generatedResult for SHA1: {generatedResult.Length}");
                } else {
                    // Calc
                    return SHA1.HashData(sharedSecret, generatedResult);
                }
            case "SHA256":
                // Check
                if (generatedResult.Length < SHA256.HashSizeInBytes) {
                    throw new ArgumentException($"Invalid length of generatedResult for SHA256: {generatedResult.Length}");
                } else {
                    // Calc
                    return SHA256.HashData(sharedSecret, generatedResult);
                }
            case "SHA384":
                // Check
                if (generatedResult.Length < SHA384.HashSizeInBytes) {
                    throw new ArgumentException($"Invalid length of generatedResult for SHA384: {generatedResult.Length}");
                } else {
                    // Calc
                    return SHA384.HashData(sharedSecret, generatedResult);
                }
            case "SHA512":
                // Check
                if (generatedResult.Length < SHA512.HashSizeInBytes) {
                    throw new ArgumentException($"Invalid length of generatedResult for SHA512: {generatedResult.Length}");
                } else {
                    // Calc
                    return SHA512.HashData(sharedSecret, generatedResult);
                }
            default:
                throw new NotSupportedException($"Not supported hash algorithm: {hashAlgorithm.Name}");
        }
    }

}
