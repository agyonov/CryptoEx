
using System;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;

namespace CryptoEx.Ed.EdDH;

/// <summary>
/// Key exchanges over the Edwards-curve Digital Signature Algorithm (EdDSA)
/// </summary>
public partial class EdDH
{
    /// <summary>
    /// Get shared secret
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <returns>The shared secred</returns>
    public byte[] GetSharedSecret(EdDH publicKey)
    {
        // Result
        byte[] sharedSecret;

        if (_PrivateKey25519 != null && publicKey._PublicKey25519 != null) {
            sharedSecret = new byte[KeySize25519 / 8];
            _PrivateKey25519.GenerateSecret(publicKey._PublicKey25519, sharedSecret);
        } else if (_PrivateKey448 != null && publicKey._PublicKey448 != null) {
            sharedSecret = new byte[KeySize448 / 8];
            _PrivateKey448.GenerateSecret(publicKey._PublicKey448, sharedSecret);
        } else {
            throw new NotSupportedException($"Not supported key pairs for EdDH");
        }

        // return
        return sharedSecret;
    }

    /// <summary>
    /// Get shared secret
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="sharedSecret">A buffer to fill with shared secred.
    /// The buffer must be at least KeySize / 8 bytes long.
    /// </param>
    /// <returns>The number of byte written to the result.</returns>
    public int GetSharedSecret(EdDH publicKey, Span<byte> sharedSecret)
    {
        if (_PrivateKey25519 != null && publicKey._PublicKey25519 != null) {
            _PrivateKey25519.GenerateSecret(publicKey._PublicKey25519, sharedSecret);
            return KeySize25519 / 8;
        } else if (_PrivateKey448 != null && publicKey._PublicKey448 != null) {
            _PrivateKey448.GenerateSecret(publicKey._PublicKey448, sharedSecret);
            return KeySize448 / 8;
        } else {
            throw new NotSupportedException($"Not supported key pairs for EdDH");
        }
    }

    /// <summary>
    /// Generate bytes, based on the shared secret.
    /// The bytes are generated by hashing the shared secret with the given hash algorithm.
    /// Number of generated bytes is equal to the size of the hash algorithm.
    /// Generated bytes may be used as a key material for symmetric encryption.
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="hashAlgorithm">The hash algorith to use</param>
    /// <param name="result">The buffer to hold the result of the operation. It's size shall be at least size of the hash algorithm used.</param>
    /// <returns>The number of actually generated secret bytes.</returns>
    public int GenerateBytes(EdDH publicKey,
                                    HashAlgorithm hashAlgorithm,
                                    Span<byte> result)
    {
        // call the other one
        return GenerateBytes(publicKey, hashAlgorithm, ReadOnlySpan<byte>.Empty, ReadOnlySpan<byte>.Empty, result);
    }

    /// <summary>
    /// Generate bytes, based on the shared secret.
    /// The bytes are generated by hashing the shared secret with the given hash algorithm.
    /// Number of generated bytes is equal to the size of the hash algorithm.
    /// Generated bytes may be used as a key material for symmetric encryption.
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="hashAlgorithm">The hash algorith to use - Hash or HMAC whatever choosed by the client</param>
    /// <param name="secretPrepend">Bytes to put on front of a shared secret, before hashing. May be empty span!</param>
    /// <param name="secretAppend">Bytes to append to the end of a shared secret, before hashing. May be empty span!</param>
    /// <param name="result">The buffer to hold the result of the operation. It's size shall be at least size of the hash algorithm used.</param>
    /// <returns>The number of actually generated secret bytes.</returns>
    public int GenerateBytes(EdDH publicKey,
                                    HashAlgorithm hashAlgorithm,
                                    ReadOnlySpan<byte> secretPrepend,
                                    ReadOnlySpan<byte> secretAppend,
                                    Span<byte> result)
    {
        // Set the result
        int success;

        // prepare some buffer
        Span<byte> sharedSecret = stackalloc byte[KeySize / 8 + secretPrepend.Length + secretAppend.Length];
        secretPrepend.CopyTo(sharedSecret);
        GetSharedSecret(publicKey, sharedSecret[secretPrepend.Length..]);
        secretAppend.CopyTo(sharedSecret[(secretPrepend.Length + KeySize / 8)..]);

        // hash
        hashAlgorithm.TryComputeHash(sharedSecret, result, out success);

        // return
        return success;
    }

    /// <summary>
    /// Derive arbitary number of secret bytes (size of Span<byte> result), using NISP's KDM method / function.
    /// See https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr2.pdf, p. 4.1
    /// The number of generated bytes is equal to the size of the provided result buffer.
    /// Generated bytes may be used as a key material for symmetric encryption.
    /// </summary>
    /// <param name="publicKey">The public key of the other party</param>
    /// <param name="hashAlgorithm">The hash algorith to use - Hash or HMAC whatever choosed by the client</param>
    /// <param name="fixedContext">A fixed context (as defined by NISP's KDM)</param>
    /// <param name="result">The buffer to hold the result of the operation</param>
    /// <returns>The number of actually generated secret bytes</returns>
    public int GenerateBytesKDM(EdDH publicKey,
                                 HashAlgorithm hashAlgorithm,
                                 ReadOnlySpan<byte> fixedContext,
                                 Span<byte> result)
    {
        // Set the result
        int success = 0;

        // calculate some values
        int reps = result.Length / (hashAlgorithm.HashSize / 8);
        int last = result.Length % (hashAlgorithm.HashSize / 8);
        int keySizeBytes = KeySize / 8;
        int hlpHashSize, index;

        // Get shared secret
        Span<byte> sharedSecret = stackalloc byte[4 + keySizeBytes + fixedContext.Length];
        if (GetSharedSecret(publicKey, sharedSecret[4..]) != keySizeBytes) {
            return success;
        }
        fixedContext.CopyTo(sharedSecret[(4 + keySizeBytes)..]);

        // define iterator
        uint counter = 0;

        // iterate
        while (counter < reps) {
            // set counter
            counter++;

            // Set it
            if (!BitConverter.TryWriteBytes(sharedSecret, counter)) {
                return success;
            }

            // hash
            index = (int)((counter - 1) * (hashAlgorithm.HashSize / 8));
            if (!hashAlgorithm.TryComputeHash(sharedSecret, result[index..], out hlpHashSize)) {
                return success;
            }
            success += hlpHashSize;
        }

        // last one
        if (last > 0) {
            // set counter
            counter++;

            // Set it
            if (!BitConverter.TryWriteBytes(sharedSecret, counter)) {
                return success;
            }

            // hash
            index = (int)((counter - 1) * hashAlgorithm.HashSize / 8);
            Span<byte> tmpBuffer = stackalloc byte[hashAlgorithm.HashSize / 8];
            if (!hashAlgorithm.TryComputeHash(sharedSecret, tmpBuffer, out hlpHashSize)) {
                return success;
            }
            tmpBuffer[..last].CopyTo(result[index..]);
            success += last;
        }

        // return
        return success;
    }
}
